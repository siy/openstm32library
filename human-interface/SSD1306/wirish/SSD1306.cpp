/*********************************************************************
This is a library for our Monochrome OLEDs based on SSD1306 drivers

  Pick one up today in the adafruit shop!
  ------> http://www.adafruit.com/category/63_98

These displays use SPI to communicate, 4 or 5 pins are required to  
interface

Adafruit invests time and resources providing this open source code, 
please support Adafruit and open-source hardware by purchasing 
products from Adafruit!

Written by Limor Fried/Ladyada  for Adafruit Industries.  
BSD license, check license.txt for more information
All text above, and the splash screen below must be included in any redistribution
*********************************************************************/
/*
Modified for Maple by Sergiy Yevtushenko <Sergiy.Yevtushenko@gmail.com>
*/

#include <WProgram.h>
#include <string.h>
#include "SSD1306.h"

#define SSD1306_STARTBYTES 2
#define TO_BIT(a)	(1 << (a))

/* Since licensing term above requires it, splash screen is preserved, but 
since it is incompatible with current driver architecture, it is commented out. */
#if 0
static uint8_t buffer[SSD1306_LCDHEIGHT * SSD1306_LCDWIDTH / 8] = { 
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80,
0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x80, 0x80, 0xC0, 0xC0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF8, 0xFC, 0xF8, 0xE0, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80,
0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x00, 0xFF,
0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00,
0x80, 0xFF, 0xFF, 0x80, 0x80, 0x00, 0x80, 0x80, 0x00, 0x80, 0x80, 0x80, 0x80, 0x00, 0x80, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x80, 0x80, 0x00, 0x00, 0x8C, 0x8E, 0x84, 0x00, 0x00, 0x80, 0xF8,
0xF8, 0xF8, 0x80, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xE0, 0xE0, 0xC0, 0x80,
0x00, 0xE0, 0xFC, 0xFE, 0xFF, 0xFF, 0xFF, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFF, 0xC7, 0x01, 0x01,
0x01, 0x01, 0x83, 0xFF, 0xFF, 0x00, 0x00, 0x7C, 0xFE, 0xC7, 0x01, 0x01, 0x01, 0x01, 0x83, 0xFF,
0xFF, 0xFF, 0x00, 0x38, 0xFE, 0xC7, 0x83, 0x01, 0x01, 0x01, 0x83, 0xC7, 0xFF, 0xFF, 0x00, 0x00,
0x01, 0xFF, 0xFF, 0x01, 0x01, 0x00, 0xFF, 0xFF, 0x07, 0x01, 0x01, 0x01, 0x00, 0x00, 0x7F, 0xFF,
0x80, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7F, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x01, 0xFF,
0xFF, 0xFF, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x03, 0x0F, 0x3F, 0x7F, 0x7F, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xE7, 0xC7, 0xC7, 0x8F,
0x8F, 0x9F, 0xBF, 0xFF, 0xFF, 0xC3, 0xC0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFC, 0xFC, 0xFC,
0xFC, 0xFC, 0xFC, 0xFC, 0xFC, 0xF8, 0xF8, 0xF0, 0xF0, 0xE0, 0xC0, 0x00, 0x01, 0x03, 0x03, 0x03,
0x03, 0x03, 0x01, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01,
0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x03, 0x03, 0x03, 0x01, 0x01, 0x03, 0x03, 0x00, 0x00,
0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x03, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01,
0x03, 0x03, 0x03, 0x03, 0x03, 0x01, 0x00, 0x00, 0x00, 0x01, 0x03, 0x01, 0x00, 0x00, 0x00, 0x03,
0x03, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
#if (SSD1306_LCDHEIGHT == 64)
0x00, 0x00, 0x00, 0x80, 0xC0, 0xE0, 0xF0, 0xF9, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x3F, 0x1F, 0x0F,
0x87, 0xC7, 0xF7, 0xFF, 0xFF, 0x1F, 0x1F, 0x3D, 0xFC, 0xF8, 0xF8, 0xF8, 0xF8, 0x7C, 0x7D, 0xFF,
0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x3F, 0x0F, 0x07, 0x00, 0x30, 0x30, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xE0, 0xC0, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0xC0, 0xFE, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0x7F, 0x7F, 0x3F, 0x1F,
0x0F, 0x07, 0x1F, 0x7F, 0xFF, 0xFF, 0xF8, 0xF8, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFE, 0xF8, 0xE0,
0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00,
0x00, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x0E, 0xFC, 0xF8, 0x00, 0x00, 0xF0, 0xF8, 0x1C, 0x0E,
0x06, 0x06, 0x06, 0x0C, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0x00, 0x00, 0xFC,
0xFE, 0xFC, 0x00, 0x18, 0x3C, 0x7E, 0x66, 0xE6, 0xCE, 0x84, 0x00, 0x00, 0x06, 0xFF, 0xFF, 0x06,
0x06, 0xFC, 0xFE, 0xFC, 0x0C, 0x06, 0x06, 0x06, 0x00, 0x00, 0xFE, 0xFE, 0x00, 0x00, 0xC0, 0xF8,
0xFC, 0x4E, 0x46, 0x46, 0x46, 0x4E, 0x7C, 0x78, 0x40, 0x18, 0x3C, 0x76, 0xE6, 0xCE, 0xCC, 0x80,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x01, 0x07, 0x0F, 0x1F, 0x1F, 0x3F, 0x3F, 0x3F, 0x3F, 0x1F, 0x0F, 0x03,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x03, 0x07, 0x0E, 0x0C,
0x18, 0x18, 0x0C, 0x06, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x01, 0x0F, 0x0E, 0x0C, 0x18, 0x0C, 0x0F,
0x07, 0x01, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00,
0x00, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x07,
0x07, 0x0C, 0x0C, 0x18, 0x1C, 0x0C, 0x06, 0x06, 0x00, 0x04, 0x0E, 0x0C, 0x18, 0x0C, 0x0F, 0x07,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
#endif
};

#endif

void SSD1306::set_contrast(uint8 contrast) {
	digitalWrite(cs, LOW);
	writeCommand(SSD1306_SETCONTRAST);
	writeCommand(contrast);
	digitalWrite(cs, HIGH);
}

void SSD1306::begin(uint8 contrast) {
	init();
	set_contrast(contrast);
}

void SSD1306::drawbitmap(uint8 x, uint8 y, const uint8 *bitmap, uint8 w,
		uint8 h, uint8 color) {
	for (uint8 j = 0; j < h; j++) {
		for (uint8 i = 0; i < w; i++) {
			if (*(bitmap + i + (j / 8) * w) & TO_BIT(j%8)) {
				setpixel(x + i, y + j, color);
			}
		}
	}
}

// bresenham's algorithm - thx wikpedia
void SSD1306::drawline(uint8 x0, uint8 y0, uint8 x1, uint8 y1, uint8 color) {
	uint8 steep = abs(y1 - y0) > abs(x1 - x0);
	if (steep) {
		swap(x0, y0);
		swap(x1, y1);
	}

	if (x0 > x1) {
		swap(x0, x1);
		swap(y0, y1);
	}

	uint8 dx, dy;
	dx = x1 - x0;
	dy = abs(y1 - y0);

	int err = dx / 2;
	int ystep;

	if (y0 < y1) {
		ystep = 1;
	} else {
		ystep = -1;
	}

	for (; x0 < x1; x0++) {
		if (steep) {
			setpixel(y0, x0, color);
		} else {
			setpixel(x0, y0, color);
		}
		err -= dy;
		if (err < 0) {
			y0 += ystep;
			err += dx;
		}
	}
}

// filled rectangle
void SSD1306::fillrect(uint8 x, uint8 y, uint8 w, uint8 h, uint8 color) {

	// stupidest version - just pixels - but fast with internal buffer!
	for (uint8 i = x; i < x + w; i++) {
		for (uint8 j = y; j < y + h; j++) {
			setpixel(i, j, color);
		}
	}
}

// draw a rectangle
void SSD1306::drawrect(uint8 x, uint8 y, uint8 w, uint8 h, uint8 color) {
	// stupidest version - just pixels - but fast with internal buffer!
	for (uint8 i = x; i < x + w; i++) {
		setpixel(i, y, color);
		setpixel(i, y + h - 1, color);
	}
	for (uint8 i = y; i < y + h; i++) {
		setpixel(x, i, color);
		setpixel(x + w - 1, i, color);
	}
}

// draw a circle outline
void SSD1306::drawcircle(uint8 x0, uint8 y0, uint8 r, uint8 color) {
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
	int x = 0;
	int y = r;

	setpixel(x0, y0 + r, color);
	setpixel(x0, y0 - r, color);
	setpixel(x0 + r, y0, color);
	setpixel(x0 - r, y0, color);

	while (x < y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		setpixel(x0 + x, y0 + y, color);
		setpixel(x0 - x, y0 + y, color);
		setpixel(x0 + x, y0 - y, color);
		setpixel(x0 - x, y0 - y, color);

		setpixel(x0 + y, y0 + x, color);
		setpixel(x0 - y, y0 + x, color);
		setpixel(x0 + y, y0 - x, color);
		setpixel(x0 - y, y0 - x, color);
	}
}

void SSD1306::fillcircle(uint8 x0, uint8 y0, uint8 r, uint8 color) {
	int f = 1 - r;
	int ddF_x = 1;
	int ddF_y = -2 * r;
	int x = 0;
	int y = r;

	for (uint8 i = y0 - r; i <= y0 + r; i++) {
		setpixel(x0, i, color);
	}

	while (x < y) {
		if (f >= 0) {
			y--;
			ddF_y += 2;
			f += ddF_y;
		}
		x++;
		ddF_x += 2;
		f += ddF_x;

		for (uint8 i = y0 - y; i <= y0 + y; i++) {
			setpixel(x0 + x, i, color);
			setpixel(x0 - x, i, color);
		}
		for (uint8 i = y0 - x; i <= y0 + x; i++) {
			setpixel(x0 + y, i, color);
			setpixel(x0 - y, i, color);
		}
	}
}

// the most basic function, set a single pixel
void SSD1306::setpixel(uint8 x, uint8 y, uint8 color) {
	if ((x >= LCDWIDTH) || (y >= LCDHEIGHT))
		return;

	// x is which column
	if (color == WHITE)
		buffer[x + (y / 8) * 128] |= TO_BIT((y%8));
	else
		buffer[x + (y / 8) * 128] &= ~TO_BIT((y%8));
}

void SSD1306::invert(uint8 i) {
	digitalWrite(cs, LOW);
	writeCommand(i ? SSD1306_INVERTDISPLAY : SSD1306_NORMALDISPLAY);
	digitalWrite(cs, HIGH);
}

void SSD1306::writeCommand(uint8 c) {
	digitalWrite(a0, LOW);
	spi.write(c);
}

void SSD1306::display(void) {
	digitalWrite(cs, LOW);
	writeCommand(SSD1306_SETLOWCOLUMN | 0x0); // low col = 0
	writeCommand(SSD1306_SETHIGHCOLUMN | 0x0); // hi col = 0
	writeCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	digitalWrite(a0, HIGH);
	spi.write(buffer, 1024);
	digitalWrite(cs, HIGH);
}

// clear everything
void SSD1306::clear(void) {
	memset(buffer, 0, 1024);
}

void SSD1306::clear_display(void) {
	clear();
	display();
}

void SSD1306::init() {
	spi.begin(SPI_18MHZ, MSBFIRST, SPI_MODE_3);

	pinMode(a0, OUTPUT);
	pinMode(cs, OUTPUT);
	pinMode(rst, OUTPUT);

	digitalWrite(cs, LOW);
	digitalWrite(rst, HIGH);
	delay(1);
	digitalWrite(rst, LOW);
	delay(10);
	digitalWrite(rst, HIGH);
	delay(10);

	writeCommand(SSD1306_DISPLAYOFF); // 0xAE
	writeCommand(SSD1306_SETDISPLAYCLOCKDIV); // 0xD5
	writeCommand(0x80); // the suggested ratio 0x80
	writeCommand(SSD1306_SETMULTIPLEX); // 0xA8
	writeCommand(0x3F); // 0x3F 1/64 duty
	writeCommand(SSD1306_SETDISPLAYOFFSET); // 0xD3
	writeCommand(0x0); // no offset
	writeCommand(SSD1306_SETSTARTLINE | 0x0); // line #0

	writeCommand(SSD1306_CHARGEPUMP); //0x8D
	writeCommand(0x04);

	writeCommand(SSD1306_MEMORYMODE); // 0x20
	//   Default => 0x02
	//     0x00 => Horizontal Addressing Mode
	//     0x01 => Vertical Addressing Mode
	//     0x02 => Page Addressing Mode
	writeCommand(0x00); // 0x0 act like ks0108

	writeCommand(SSD1306_SEGREMAP | 0x1); //A0
	writeCommand(SSD1306_COMSCANDEC); //scan direction

	writeCommand(SSD1306_SETCOMPINS);
	writeCommand(0x12); // disable COM left/right remap

	writeCommand(SSD1306_SETCONTRAST); // 0x81
	writeCommand(0xCF);

	writeCommand(SSD1306_SETPRECHARGE); // 0xd9
	writeCommand(0xF1); // DC/DC

	writeCommand(SSD1306_SETVCOMDETECT); // 0xDB
	writeCommand(0x40); // 0x20 is default?

	writeCommand(SSD1306_NORMALDISPLAY); // 0xA6
	writeCommand(SSD1306_DISPLAYALLON_RESUME); // 0xA4

	writeCommand(SSD1306_DISPLAYON);
	digitalWrite(cs, HIGH);
}

void SSD1306::drawchar(uint8 x, uint8 line, uint8 c) {
	c -= font.first;
	int nrows = font.height / 8;
	int fontStart = c * font.width * nrows;
	for (uint8 j = 0; j < nrows; j++) {
		int bufferStart = x + (line + j) * 128;
		for (uint8 i = 0; i < font.width; i++) {
			buffer[bufferStart + i] = font.data[fontStart++];
		}
	}
}

void SSD1306::drawstring(uint8 x, uint8 line, const char *c) {
	while (c[0] != 0) {
		drawchar(x, line, c[0]);
		c++;
		x += font.width + 1; // extra pixel for spacing
		if (x + font.width + 1 >= LCDWIDTH) {
			x = 0; // ran out of this line
			line += font.height/8;
		}
		if (line >= (LCDHEIGHT / 8))
			return; // ran out of space :(
	}
}
